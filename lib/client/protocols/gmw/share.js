/**
 * The function to compute the shares of input (can be overridden using hooks).
 * @ignore
 * @function gmw_compute_share
 * @param {module:jiff-client~JIFFClient} jiff - the jiff instance
 * @param {number} the secret to share
 * @param {Array} parties_list - array of party ids to share with.
 * @param {number} threshold - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
 * @param {number} Zp - the mod.
 * @returns {object} a map between party number and its share
 */
function gmw_compute_share(jiff, input, parties_list, threshold, Zp) {
  var ls = {};  // potential shares of length n
  var i;
  var len = parties_list.length;
  for (i = 0; i < len-1; i++) {
    var b = jiff.helpers.random(2);  // random bit
    ls[parties_list[i]] = b;
  }
  var sum = ls[parties_list[0]];
  for (i = 1; i < parties_list.length-1; i++) {
    sum = sum ^ ls[parties_list[i]];
  }
  sum = sum ^ input;
  ls[parties_list[i]] = sum;
  return ls;
}



/**
 * Share given secret to the participating parties.
 * @ignore
 * @function gmw_share
 * @param {module:jiff-client~JIFFClient} jiff - the jiff instance
 * @param {number} secret - the secret to share.
 * @param {number} [threshold=receivers_list.length] - the min number of parties needed to reconstruct the secret, defaults to all the receivers.
 * @param {Array} [receivers_list=all_parties] - array of party ids to share with, by default, this includes all parties.
 * @param {Array} [senders_list=all_parties] - array of party ids to receive from, by default, this includes all parties.
 * @param {number} [Zp=jiff.Zp] - the mod (if null then the default Zp for the instance is used).
 * @param {string|number} [share_id=auto_gen()] - the tag used to tag the messages sent by this share operation, this tag is used
 *                                   so that parties distinguish messages belonging to this share operation from other
 *                                   share operations between the same parties (when the order of execution is not
 *                                   deterministic). An automatic id is generated by increasing a local counter, default
 *                                   ids suffice when all parties execute all sharing operations with the same senders
 *                                   and receivers in the same order.
 * @returns {object} a map where the key is the sender party id
 *          and the value is the share object that wraps
 *          what was sent from that party (the internal value maybe deferred).
 *          if the party that calls this function is not a receiver then the map
 *          will be empty.
 */
function gmw_share(jiff, secret, threshold, receivers_list, senders_list, Zp, share_id) {
  var i, p_id;

  // defaults
  if (Zp == null) {
    Zp = 2;
  }
  if (receivers_list == null) {
    receivers_list = [];
    for (i = 1; i <= jiff.party_count; i++) {
      receivers_list.push(i);
    }
  } else {
    jiff.helpers.sort_ids(receivers_list);
  }

  if (senders_list == null) {
    senders_list = [];
    for (i = 1; i <= jiff.party_count; i++) {
      senders_list.push(i);
    }
  } else {
    jiff.helpers.sort_ids(senders_list);
  }
  if (threshold == null) {
    threshold = receivers_list.length;
  }
  if (threshold < 0) {
    threshold = 2;
  }
  if (threshold > receivers_list.length) {
    threshold = receivers_list.length;
  }

  // if party is uninvolved in the share, do nothing
  if (receivers_list.indexOf(jiff.id) === -1 && senders_list.indexOf(jiff.id) === -1) {
    return {};
  }


  // compute operation id
  if (share_id == null) {
    share_id = jiff.counters.gen_op_id2('GMW_share', receivers_list, senders_list);
  }

  // stage sending of shares
  if (senders_list.indexOf(jiff.id) > -1) {
    // Call hook
    secret = jiff.hooks.execute_array_hooks('beforeShare', [jiff, secret, threshold, receivers_list, senders_list, Zp], 1);

    // compute shares
    var shares = gmw_compute_share(jiff, secret, receivers_list, threshold, Zp);

    // Call hook
    shares = jiff.hooks.execute_array_hooks('afterComputeShare', [jiff, shares, threshold, receivers_list, senders_list, Zp], 1);

    // send shares
    for (i = 0; i < receivers_list.length; i++) {
      p_id = receivers_list[i];
      if (p_id === jiff.id) {
        continue;
      }

      // send encrypted and signed shares_id[p_id] to party p_id
      var msg = {
        party_id: p_id,
        share: shares[p_id],
        op_id: share_id
      };
      msg = jiff.hooks.execute_array_hooks('beforeOperation', [jiff, 'share', msg], 2);
      msg['share'] = jiff.hooks.encryptSign(jiff, msg['share'].toString(10), jiff.keymap[msg['party_id']], jiff.secret_key);
      jiff.socket.safe_emit('share', JSON.stringify(msg));

    }
  }

  // stage receiving of shares
  var result = {};
  if (receivers_list.indexOf(jiff.id) > -1) {
    // setup a map of deferred for every received share
    if (jiff.deferreds[share_id] == null) {
      jiff.deferreds[share_id] = {};
    }

    var _remaining = senders_list.length;
    for (i = 0; i < senders_list.length; i++) {
      p_id = senders_list[i];
      if (p_id === jiff.id) { // Keep party's own share
        var my_share = jiff.hooks.execute_array_hooks('receiveShare', [jiff, p_id, shares[p_id]], 2);

        result[p_id] = new jiff.SecretShare(my_share, receivers_list, threshold, Zp);
        _remaining--;
        continue;
      }

      // check if a deferred is set up (maybe the message was previously received)
      if (jiff.deferreds[share_id][p_id] == null) { // not ready, setup a deferred
        jiff.deferreds[share_id][p_id] = new jiff.helpers.Deferred();

      }

      var promise = jiff.deferreds[share_id][p_id].promise;
      // destroy deferred when done
      (function (promise, p_id) { // p_id is modified in a for loop, must do this to avoid scoping issues.
        promise.then(function () {
          delete jiff.deferreds[share_id][p_id];
          _remaining--;
          if (_remaining === 0) {
            delete jiff.deferreds[share_id];
          }
        });
      })(promise, p_id);

      // receive share_i[id] from party p_id
      result[p_id] = new jiff.SecretShare(promise, receivers_list, threshold, Zp);
    }
  }

  return result;
}

module.exports = {
  gmw_share: gmw_share
};
